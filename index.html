<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>VoiceNote - Multi-language Speech to Text</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 1rem 0; /* ADDED vertical padding to ensure content can scroll */
      background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
      color: #333;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      /* CHANGE: Align to the start to allow scrolling */
      align-items: flex-start; 
    }
    .container {
      background-color: #fff;
      padding: 2rem;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      width: min(90vw, 800px);
      /* CHANGE: Use auto-height to fit content properly */
      min-height: auto; 
      height: auto;
      margin: 2rem auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
    }
    .header {
      text-align: center;
      margin-bottom: 2rem;
    }
    .header i {
      font-size: 3rem;
      color: #0984e3;
      margin-bottom: 0.5rem;
    }
    h1 {
      text-align: center;
      color: #4a4a4a;
      margin-bottom: 0.5rem;
      font-size: 2.5rem;
      font-weight: 300;
    }
    .subtitle {
      text-align: center;
      color: #888;
      font-size: 1.2rem;
      margin-bottom: 1rem;
      font-weight: 300;
    }
    .voice-icons {
      text-align: center;
      margin-bottom: 1rem;
    }
    .voice-icons i {
      display: none;
    }
    .voice-image {
      display: block;
      margin: 0 auto 1rem auto;
      max-width: 150px;
      opacity: 0.8;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }
    label {
      font-weight: bold;
      margin-right: 0.5rem;
    }
    select {
      font-size: 1rem;
      padding: 0.75rem;
      margin: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      background-color: #fff;
      cursor: pointer;
      transition: border-color 0.3s ease;
    }
    select:hover {
      border-color: #0984e3;
    }
    button {
      font-size: 1rem;
      padding: 0.75rem 1.5rem;
      margin: 0.5rem;
      border: none;
      border-radius: 5px;
      background-color: #0984e3;
      color: #fff;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
      font-weight: bold;
    }
    button:hover {
      background-color: #0652dd;
      transform: translateY(-2px);
    }
    button:active {
      transform: translateY(0);
    }
    #transcript {
      width: 100%;
      /* CHANGE: Reduced height from 500px to better fit on all screens */
      height: 350px; 
      /* NEW: Allows the textarea to grow if extra space is available */
      flex-grow: 1; 
      font-size: 1.1rem;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      resize: none;
      background-color: #fafafa;
      line-height: 1.5;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: border-color 0.3s ease;
      overflow-y: auto;
    }
    #transcript:focus {
      outline: none;
      border-color: #0984e3;
    }
    #status {
      text-align: center;
      margin-top: 1.5rem;
      font-style: italic;
      color: #888;
      font-size: 1rem;
    }
    footer {
      text-align: center;
      margin-top: 2rem;
      font-size: 0.9rem;
      color: #aaa;
      border-top: 1px solid #eee;
      padding-top: 1rem;
    }
    @media (max-width: 768px) {
      body {
        /* Ensure scrolling is enabled for the entire page */
        display: block; 
        overflow-y: auto;
        padding: 1rem;
      }
      .container {
        width: 100%;
        padding: 1rem;
        margin: 0;
        min-height: auto;
        height: auto;
        box-shadow: none;
      }
      h1 {
        font-size: 2rem;
      }
      #controls {
        flex-direction: column;
        gap: 0.5rem;
        text-align: center;
      }
      select, button {
        width: 100%;
        max-width: 300px;
        margin: 0.25rem auto;
      }
      /* CHANGE: Reduced height from 60vh to 35vh for better visibility of footer */
      #transcript {
        height: 35vh; 
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>VoiceNote</h1>
      <p class="subtitle">Optimized for Telugu and Tamil Speech to Text</p>
      <div class="voice-icons">
      </div>
    </div>
    <div id="controls">
      <label for="language"><i class="fas fa-globe"></i> Select Language: </label>
      <select id="language"></select>
      <label for="translateLanguage"><i class="fas fa-language"></i> Translate to: </label>
      <select id="translateLanguage"></select>
      <label for="noiseReduction" style="display: none;"><input type="checkbox" id="noiseReduction"> Enable Noise Reduction</label>
      <label for="audioFile" style="display: none;"><i class="fas fa-upload"></i> Upload Audio File: <input type="file" id="audioFile" accept="audio/*"></label>

      <button id="startBtn"><i class="fas fa-play"></i> Start</button>
      <button id="stopBtn" disabled><i class="fas fa-stop"></i> Stop</button>
      <button id="translateBtn"><i class="fas fa-exchange-alt"></i> Translate</button>
      <button id="saveBtn"><i class="fas fa-save"></i> Save Transcription</button>
      <button id="copyBtn"><i class="fas fa-copy"></i> Copy</button>
      <button id="clearBtn"><i class="fas fa-trash-alt"></i> Clear</button>
    </div>
    <textarea id="transcript" placeholder="Your speech will appear here..." readonly></textarea>
    <div id="status"></div>
    <footer>Powered by Web Speech API</footer>
  </div>

  <script>
    // List of languages supported by Web Speech API (common ones), prioritized for Telugu and Tamil
    const languages = [
      { code: 'te-IN', name: 'Telugu (India)' },
      { code: 'ta-IN', name: 'Tamil (India)' },
      { code: 'en-US', name: 'English (United States)' },
      { code: 'en-GB', name: 'English (United Kingdom)' },
      { code: 'es-ES', name: 'Spanish (Spain)' },
      { code: 'fr-FR', name: 'French (France)' },
      { code: 'de-DE', name: 'German (Germany)' },
      { code: 'it-IT', name: 'Italian (Italy)' },
      { code: 'ja-JP', name: 'Japanese (Japan)' },
      { code: 'zh-CN', name: 'Chinese (Mandarin, Simplified)' },
      { code: 'zh-TW', name: 'Chinese (Mandarin, Traditional)' },
      { code: 'ru-RU', name: 'Russian (Russia)' },
      { code: 'ar-SA', name: 'Arabic (Saudi Arabia)' },
      { code: 'hi-IN', name: 'Hindi (India)' },
      { code: 'bn-IN', name: 'Bengali (India)' },
      { code: 'mr-IN', name: 'Marathi (India)' },
      { code: 'ur-IN', name: 'Urdu (India)' },
      { code: 'gu-IN', name: 'Gujarati (India)' },
      { code: 'kn-IN', name: 'Kannada (India)' },
      { code: 'or-IN', name: 'Odia (India)' },
      { code: 'ml-IN', name: 'Malayalam (India)' },
      { code: 'pa-IN', name: 'Punjabi (India)' },
      { code: 'as-IN', name: 'Assamese (India)' },
      { code: 'mai-IN', name: 'Maithili (India)' },
      { code: 'pt-BR', name: 'Portuguese (Brazil)' },
      { code: 'ko-KR', name: 'Korean (South Korea)' },
      { code: 'nl-NL', name: 'Dutch (Netherlands)' },
      { code: 'sv-SE', name: 'Swedish (Sweden)' },
      { code: 'tr-TR', name: 'Turkish (Turkey)' },
      { code: 'pl-PL', name: 'Polish (Poland)' },
      { code: 'he-IL', name: 'Hebrew (Israel)' },
      { code: 'th-TH', name: 'Thai (Thailand)' },
      { code: 'vi-VN', name: 'Vietnamese (Vietnam)' },
      { code: 'fa-IR', name: 'Persian (Iran)' },
      { code: 'id-ID', name: 'Indonesian (Indonesia)' },
      { code: 'ms-MY', name: 'Malay (Malaysia)' },
      { code: 'ro-RO', name: 'Romanian (Romania)' },
      { code: 'hu-HU', name: 'Hungarian (Hungary)' },
      { code: 'el-GR', name: 'Greek (Greece)' },
      { code: 'cs-CZ', name: 'Czech (Czech Republic)' },
      { code: 'da-DK', name: 'Danish (Denmark)' },
      { code: 'fi-FI', name: 'Finnish (Finland)' },
      { code: 'no-NO', name: 'Norwegian (Norway)' }
    ];

    const languageSelect = document.getElementById('language');
    const translateLanguageSelect = document.getElementById('translateLanguage');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const translateBtn = document.getElementById('translateBtn');
    const transcriptArea = document.getElementById('transcript');
    const statusDiv = document.getElementById('status');
    const saveBtn = document.getElementById('saveBtn');

    // Populate language dropdown
    languages.forEach(lang => {
      const option = document.createElement('option');
      option.value = lang.code;
      option.textContent = lang.name;
      languageSelect.appendChild(option);
    });

    // Populate translate language dropdown (same as recognition languages)
    languages.forEach(lang => {
      const option = document.createElement('option');
      option.value = lang.code;
      option.textContent = lang.name;
      translateLanguageSelect.appendChild(option);
    });

    // Set default language to Telugu
    languageSelect.value = 'te-IN';
    // Set default translate language to English
    translateLanguageSelect.value = 'en-US';

    let recognition;
    let isRecognizing = false;
    let shouldStop = false;
    let audioContext;
    let filteredStream;
    let accumulatedTranscript = '';

    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
      statusDiv.textContent = 'Sorry, your browser does not support Speech Recognition.';
      startBtn.disabled = true;
      stopBtn.disabled = true;
      saveBtn.disabled = true;
    } else {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onstart = () => {
        isRecognizing = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        statusDiv.textContent = 'Listening...';
      };

      recognition.onerror = (event) => {
        statusDiv.textContent = 'Error occurred in recognition: ' + event.error;
      };

      recognition.onend = () => {
        if (shouldStop) {
          isRecognizing = false;
          startBtn.disabled = false;
          stopBtn.disabled = true;
          statusDiv.textContent = 'Stopped listening.';
          if (audioContext) {
            audioContext.close();
            audioContext = null;
          }
          if (filteredStream) {
            filteredStream.getTracks().forEach(track => track.stop());
            filteredStream = null;
          }
        } else {
          // Restart recognition if not manually stopped
          recognition.start();
        }
      };

      recognition.onresult = (event) => {
        let interimTranscript = '';
        for (let i = event.resultIndex; i < event.results.length; ++i) {
          if (event.results[i].isFinal) {
            accumulatedTranscript += event.results[i][0].transcript;
          } else {
            interimTranscript += event.results[i][0].transcript;
          }
        }
        transcriptArea.value = accumulatedTranscript + interimTranscript;
      };
    }

    startBtn.addEventListener('click', async () => {
      shouldStop = false;
      recognition.lang = languageSelect.value;
      accumulatedTranscript = '';
      transcriptArea.value = '';

      if (document.getElementById('noiseReduction').checked) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioContext.createMediaStreamSource(stream);

          // High-pass filter to remove low-frequency noise (e.g., rumble)
          const highPassFilter = audioContext.createBiquadFilter();
          highPassFilter.type = 'highpass';
          highPassFilter.frequency.value = 80;

          // Low-pass filter to remove high-frequency noise (e.g., hiss)
          const lowPassFilter = audioContext.createBiquadFilter();
          lowPassFilter.type = 'lowpass';
          lowPassFilter.frequency.value = 3400;

          // Compressor to even out volume and reduce dynamic noise
          const compressor = audioContext.createDynamicsCompressor();
          compressor.threshold.value = -24;
          compressor.knee.value = 30;
          compressor.ratio.value = 12;
          compressor.attack.value = 0.003;
          compressor.release.value = 0.25;

          // Chain the filters: source -> highPass -> lowPass -> compressor -> destination
          source.connect(highPassFilter);
          highPassFilter.connect(lowPassFilter);
          lowPassFilter.connect(compressor);

          const destination = audioContext.createMediaStreamDestination();
          compressor.connect(destination);
          filteredStream = destination.stream;

          // If browser supports, set the filtered audio track
          if ('audioTrack' in recognition) {
            recognition.audioTrack = filteredStream.getAudioTracks()[0];
          } else {
            statusDiv.textContent = 'Noise reduction not fully supported in this browser, starting without it.';
          }
        } catch (error) {
          statusDiv.textContent = 'Error accessing microphone for noise reduction: ' + error.message;
          return;
        }
      }

      recognition.start();
    });

    stopBtn.addEventListener('click', () => {
      shouldStop = true;
      recognition.stop();
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }
      if (filteredStream) {
        filteredStream.getTracks().forEach(track => track.stop());
        filteredStream = null;
      }
    });

    saveBtn.addEventListener('click', () => {
      const text = transcriptArea.value.trim();
      if (!text) {
        alert('No transcription to save.');
        return;
      }
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'transcription.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    const copyBtn = document.getElementById('copyBtn');
    const clearBtn = document.getElementById('clearBtn');

    copyBtn.addEventListener('click', () => {
      const text = transcriptArea.value.trim();
      if (!text) {
        alert('No transcription to copy.');
        return;
      }
      navigator.clipboard.writeText(text).then(() => {
        alert('Transcription copied to clipboard.');
      }).catch(() => {
        alert('Failed to copy transcription. Please copy manually.');
      });
    });

    clearBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to clear the transcription?')) {
        transcriptArea.value = '';
      }
    });

    // Translation function using Google Translate API (unofficial)
    async function translateText(text, sourceLang, targetLang) {
      // NOTE: This endpoint is unofficial and may stop working without notice.
      const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`;
      try {
        const response = await fetch(url);
        const data = await response.json();
        // The translated text is usually the first element of the first array of the main array
        return data[0][0][0]; 
      } catch (error) {
        console.error('Translation error:', error);
        return null;
      }
    }

    translateBtn.addEventListener('click', async () => {
      if (!navigator.onLine) {
        statusDiv.textContent = 'No internet connection. Translation requires internet.';
        return;
      }
      const text = transcriptArea.value.trim();
      if (!text) {
        alert('No text to translate.');
        return;
      }
      // Extract language code (e.g., 'te' from 'te-IN') for the translate API
      const sourceLang = languageSelect.value.split('-')[0];
      const targetLang = translateLanguageSelect.value.split('-')[0];

      if (sourceLang === targetLang) {
        statusDiv.textContent = 'Source and target languages are the same. No translation needed.';
        return;
      }
      statusDiv.textContent = 'Translating...';
      const translatedText = await translateText(text, sourceLang, targetLang);

      if (translatedText) {
        // Display the translated text in the transcript area
        transcriptArea.value = translatedText;
        statusDiv.textContent = `Translation from ${sourceLang.toUpperCase()} to ${targetLang.toUpperCase()} completed.`;
      } else {
        statusDiv.textContent = 'Translation failed. Please try again or check console for errors.';
      }
    });
  </script>

  <script>
    // Audio file upload and speech recognition
    const audioFileInput = document.getElementById('audioFile');
    let audioElement = null;
    let fileAudioContext = null;
    let fileStream = null;

    audioFileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (!file) {
        return;
      }
      
      // Cleanup previous streams/elements
      if (audioElement) {
        audioElement.pause();
        audioElement.remove();
        audioElement = null;
      }
      if (fileAudioContext) {
        fileAudioContext.close();
        fileAudioContext = null;
      }
      if (fileStream) {
        fileStream.getTracks().forEach(track => track.stop());
        fileStream = null;
      }

      try {
        const arrayBuffer = await file.arrayBuffer();
        fileAudioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffer = await fileAudioContext.decodeAudioData(arrayBuffer);

        const source = fileAudioContext.createBufferSource();
        source.buffer = audioBuffer;

        const destination = fileAudioContext.createMediaStreamDestination();
        source.connect(destination);
        fileStream = destination.stream;

        // Create audio element for playback
        const url = URL.createObjectURL(file);
        audioElement = new Audio(url);
        audioElement.controls = true;
        audioElement.autoplay = false;
        audioElement.style.display = 'block';
        audioElement.style.width = '100%';
        audioElement.style.margin = '1rem auto 0 auto';
        document.querySelector('.container').insertBefore(audioElement, document.getElementById('transcript'));

        // Attempt to set the file stream to recognition if supported
        if ('audioTrack' in recognition) {
          recognition.audioTrack = fileStream.getAudioTracks()[0];
          statusDiv.textContent = 'Audio file loaded. Click Start to transcribe.';
          
          // Connect the stream source to recognition and start playback (which feeds recognition)
          startBtn.addEventListener('click', () => {
              // The stream is started when the file is loaded, but playback starts here.
              // Note: Direct file transcription via Web Speech API is experimental 
              // and often not fully supported by browsers.
              if (source && fileAudioContext.state === 'suspended') {
                  fileAudioContext.resume();
              }
          }, { once: true }); // Only set this handler once per file load
          
        } else {
          statusDiv.textContent = 'Audio playback ready. Note: Direct Speech-to-text from an uploaded audio file is not widely supported in this browser.';
        }

      } catch (error) {
        statusDiv.textContent = 'Error loading audio file: ' + error.message;
      }
    });
  </script>
</body>
</html>